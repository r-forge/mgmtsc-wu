
\section{Implementierung in R}
\label{sec:R}

Die Fit-Funktion ist als generische Funktion implementiert und sieht
folgendermaßen aus:

\begin{Schunk}
\begin{Sinput}
> CopulaFit <- function(x, y, method = "CML", returns = FALSE, 
+     ...) {
+     UseMethod("CopulaFit")
+ }
\end{Sinput}
\end{Schunk}

\begin{itemize}
\item \verb|x| und \verb|y| sind die Datenpunkte der zwei Zeitreihen,
  die untersucht werden sollen. Es m\"ussen entweder Kurswerte oder
  gleich Renditen eingegeben werden.

\item \verb|method| steht hierbei f\"ur die Fit-Methode, die verwendet 
werden soll. Es stehen die Methoden \verb|"CML"|, \verb|"EML"| und 
\verb|"IFM"| zur Verf\"ugung.

\item \verb|returns| ist eine Kontrollvariable. Sind in den
  Datenvektoren \verb|x| und \verb|y| bereits Renditen enthalten, so
  muss \verb|returns = TRUE| gesetzt werden.
\end{itemize}

Die benötigte Klasse f\"ur die Funktion \verb|CopulaFit| heißt
\verb|"ml"|. Die Datenreihen werden jedoch automatisch in diese Klasse
umgewandelt. Allerdings kann dies auch manuell mit der Funktion geschehen:

\begin{Schunk}
\begin{Sinput}
> as.ml <- function(x, returns = FALSE) {
+     library(fSeries)
+     if (returns == FALSE) {
+         x <- as.timeSeries(x)
+         x <- returnSeries(x)
+         x <- x@Data
+     }
+     class(x) <- "ml"
+     x
+ }
\end{Sinput}
\end{Schunk}

Je nachdem, welche \verb|method| in \verb|CopulaFit| angegeben wird,
wird die passende Funktion ausgef\"uhrt:

\subsection{EML-Methode}
\label{sec:Reml}

Die Funktion, die aufgerufen wird, heißt \verb|.EMLfit|. Die Parameter
werden automatisch \"ubergeben. Diese Methode funktioniert derzeit
f\"ur zwölf Copulae (archimedische Copulae 1, 3-6, 9-10,
12-14, 16-17 nach \cite{nelsen2006}) und f\"ur alle vier Kombinationen
von Randverteilungen 
(zB Randverteilung von \verb|x| = t-Verteilung und Randverteilung von
\verb|y| = Normalverteilung). Bei Anwendung anderer Verteilungen
treten derzeit noch Fehler auf.

Da die Parameter der Randverteilungen und der Copulae gleichzeitig
geschätzt werden m\"ussen, gibt es einige Hindernisse, die bei dieser
EML-Methode \"uberwunden werden m\"ussen: 

\begin{itemize}
\item \verb|upperbounds| und \verb|lowerbounds| beschreibt die oberen
  und unteren Grenzen, welche während der Parameterschätzung nicht
  unter- bzw. \"uberschritten werden d\"urfen.
\item \verb|startwerte| \"ubergibt dem Optimierer passende Startwerte.
\item In \verb|fun| wird die zu minimierende Zielfunktion
  definiert. Diese entspricht Gleichung \ref{eq:EML}. Mit der Funktion
  \verb|do.call| wird daf\"ur gesorgt, dass immer alle möglichen
  Kombinationen von Copulae und Randverteilungen mit den passenden
  Parametern aufgerufen werden. Die möglichen Kombinationen werden mit
  \verb|makelist()| erzeugt.
\end{itemize}


\subsection{IFM-Methode}
\label{sec:Rifm}

Diese Methode funktioniert derzeit ebenfalls f\"ur zwölf Copulae
(archimedische Copulae 1, 3-6, 9-10, 12-14, 16-17 nach
\cite{nelsen2006}) und f\"ur jeweils
f\"unf verschiedene Randverteilungen (Normal- und t-Verteilung,
Generalised Hyperbolic Distribution, Hyperbolic Distribution, Normal
Inverse Gaussian Distribution).

Die Funktion \verb|.IFMfit| sucht im ersten Schritt nach den
Randverteilungen und deren Parametern, die am besten zu den
Datenreihen \verb|x| und \verb|y| passen. Dies geschieht durch
internen Aufruf der Funktion \verb|.marginFit|. \verb|.pmarginFit|
berechnet dann die Wahrscheinlichkeiten der Datenpunkte mit den
angepassten Verteilungen.

In \verb|fun| wird wieder die zu minimierende Zielfunktion
definiert. Diese entspricht Gleichung \ref{eq:IFMcopula}. Da bei der
Schätzung der Copula nur der Parameter f\"ur die jeweilige Copula
angepasst wird, reicht es einen Startparameter und die Grenzen f\"ur
jede Copula zu definieren. Dies geschieht in den Objekten \verb|alpha|
und \verb|range|.



\subsection{CML-Methode}
\label{sec:Rcml}

Hier m\"ussen zunächst die empirischen Verteilungsfunktionen der
Datenreihen \verb|x| und \verb|x| berechnet werden. Dazu wurde
folgende Funktion implementiert:

\begin{Schunk}
\begin{Sinput}
> pemp <- function(t, x) {
+     F <- NULL
+     for (i in 1:length(t)) {
+         F <- c(F, 1/length(x) * sum(x <= t[i]))
+     }
+     F
+ }
\end{Sinput}
\end{Schunk}

Somit m\"ussen auch hier nur die Parameter der Copulae geschätzt
werden. Die zu optimierende Funktion (Gleichung \ref{eq:CML}) ist in \verb|fun|
definiert. Startparameter und Grenzen werden in \verb|alpha| und
\verb|range| angegeben.


\subsection{Anwendungsbeispiel}
\label{sec:Rbeispiel}

\subsubsection{Durchf\"uhrung einer Anpassung}
\label{sec:Durchfuehrung}

Nun soll die Funktion \verb|CopulaFit| an einem genierierten
Beispieldatensatz angewendet werden:


\begin{Schunk}
\begin{Sinput}
> x <- rnorm(100, 760, 23)
> y <- rnorm(100, 500, 99)
> x <- as.ml(x, returns = FALSE)
> y <- as.ml(y, returns = FALSE)
\end{Sinput}
\end{Schunk}

Die Datenvektoren werden jetzt aufbereitet. Auch diese haben eine
eigene print-Methode:

\begin{Schunk}
\begin{Sinput}
> x
\end{Sinput}
\begin{Soutput}
This is a time series containing  99 returns.
Prepared for calling the function "CopulaFit" 
\end{Soutput}
\begin{Sinput}
> y
\end{Sinput}
\begin{Soutput}
This is a time series containing  99 returns.
Prepared for calling the function "CopulaFit" 
\end{Soutput}
\end{Schunk}

Nun kann die Anpassung durchgef\"uhrt werden. Im folgenden Beispiel
werden die Copulae der oben definierten Datenreihen nach der
IFM-Methode geschätzt:

\begin{Schunk}
\begin{Sinput}
> ifm <- CopulaFit(x, y, method = "IFM", returns = TRUE)
\end{Sinput}
\end{Schunk}

Die Ausgabe von \verb|fit| liefert nun eine \"Ubersicht \"uber die
Parameter, den Log-Likelihood-Wert und der verwendeten Methode aller
gefitteten Copulae.

\begin{Schunk}
\begin{Sinput}
> ifm
\end{Sinput}
\begin{Soutput}
   fit.family     fit.par fit.objective fit.method fit.convergence  fit.AIC
1    Archm. 1  0.20053613 -2.386252e-03        IFM               0 1.995227
2    Archm. 3  0.03803663 -1.869869e-05        IFM               0 1.999963
3    Archm. 4  1.00000000 -2.242875e-18        IFM               0 2.000000
4    Archm. 5  0.06693089 -1.636559e-05        IFM               0 1.999967
5    Archm. 6  1.00000000  1.233581e-17        IFM               0 2.000000
6    Archm. 9  0.00000000  0.000000e+00        IFM               0 2.000000
7   Archm. 10  0.00000000  0.000000e+00        IFM               0 2.000000
8   Archm. 12  1.00000000  5.460098e-02        IFM               0 2.109202
9   Archm. 13  1.17860348 -4.582247e-04        IFM               0 1.999084
10  Archm. 14  1.00000000  5.460098e-02        IFM               0 2.109202
11  Archm. 16  0.32253662  1.949495e-02        IFM               0 2.038990
12  Archm. 17 -0.70131228 -9.545983e-05        IFM               0 1.999809
\end{Soutput}
\end{Schunk}

Um schneller jene Copula wählen zu können, welche den maximalen
Log-Likelihood-Wert liefert, kann der Befehl \verb|summary| verwendet
werden. Die Ausgabe zeigt die besten drei Copulae an:

\begin{Schunk}
\begin{Sinput}
> summary(ifm)
\end{Sinput}
\begin{Soutput}
 Die best-fit Copula ist Typ:  Archm. 1 
 Minimaler Zielfunktionswert:  -0.002386252 

Summary:
  a.family.ind. a.objective.ind. a.method.ind. a.par.ind. a.AIC.ind.
1      Archm. 1    -2.386252e-03           IFM  0.2005361   1.995227
2     Archm. 13    -4.582247e-04           IFM  1.1786035   1.999084
3     Archm. 17    -9.545983e-05           IFM -0.7013123   1.999809
  a.convergence.ind.
1                  0
2                  0
3                  0
\end{Soutput}
\end{Schunk}

Weitere Informationen können \"uber S3-Attribute ausgegeben werden. Es
stehen folgende Attribute zur Verf\"ugung:

\begin{Schunk}
\begin{Sinput}
> attributes(ifm)
\end{Sinput}
\begin{Soutput}
$names
 [1] "margin1"      "distrmargin1" "margin2"      "distrmargin2" "family"      
 [6] "par"          "objective"    "AIC"          "convergence"  "message"     
[11] "iterations"   "method"      

$class
[1] "mloutput"
\end{Soutput}
\end{Schunk}

Mit Hilfe dieser Attribute können zusätzlich noch Informationen \"uber
die Randverteilungen, die Anzahl der Iterationen und eine Nachricht
\"uber das Konvergenzverhalten ausgegeben werden.


\subsubsection{Vergleich der Fit-Methoden}
\label{sec:VergleichFitMethoden}

Nun sollen die verschiednen Fit-Methoden verglichen werden. Dazu
werden zwei Zeitreihen verwendet, die von \emph{YahooFinance} besorgt
wurden. Es handelt sich um Zeitreihen von ATX- und NIKKEI-Werten, die
schon mit \verb|as.ml| f\"ur die Anpassung vorbereitet worden sind.

\begin{Schunk}
\begin{Sinput}
> ifm <- CopulaFit(x, y, method = "IFM", returns = TRUE)
> cml <- CopulaFit(x, y, method = "CML", returns = TRUE)
> eml <- CopulaFit(x, y, method = "EML", returns = TRUE)
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> summary(cml)
\end{Sinput}
\begin{Soutput}
 Die best-fit Copula ist Typ:  Archm. 5 
 Minimaler Zielfunktionswert:  -0.0001179483 

Summary:
  a.family.ind. a.objective.ind. a.method.ind.  a.par.ind. a.AIC.ind.
1      Archm. 5    -0.0001179483           CML  0.09181627   1.999764
2      Archm. 3    -0.0001178839           CML  0.04533770   1.999764
3     Archm. 17    -0.0001069186           CML -0.84801622   1.999786
  a.convergence.ind.
1                  0
2                  0
3                  0
\end{Soutput}
\begin{Sinput}
> summary(ifm)
\end{Sinput}
\begin{Soutput}
 Die best-fit Copula ist Typ:  Archm. 5 
 Minimaler Zielfunktionswert:  -0.0001063884 

Summary:
  a.family.ind. a.objective.ind. a.method.ind.   a.par.ind. a.AIC.ind.
1      Archm. 5    -1.063884e-04           IFM  0.102855182   1.999787
2      Archm. 3    -1.053455e-04           IFM  0.050244838   1.999789
3      Archm. 1    -9.037212e-05           IFM -0.008746649   1.999819
  a.convergence.ind.
1                  0
2                  0
3                  0
\end{Soutput}
\begin{Sinput}
> summary(eml)
\end{Sinput}
\begin{Soutput}
 Die best-fit Copula ist Typ:  Archm. 5 
 Minimaler Zielfunktionswert:  -2.299921 

Summary:
  a.family.ind. a.objective.ind. a.method.ind. a.parCopula.ind. a.AIC.ind.
1      Archm. 5        -2.299921           EML        12.529208   3.400158
2      Archm. 4        -2.294417           EML         6.753759   3.411167
3     Archm. 14        -2.293418           EML         6.870347   3.413164
  a.convergence.ind.
1                  1
2                  1
3                  1
\end{Soutput}
\end{Schunk}

Wie man sieht, empfiehlt jede Fit-Methode die Archimedische Copula 5,
wobei die Konvergenz bei der EML-Methode nicht gegeben ist. Um
genauere Informationen \"uber die Konvergenzvariable zu erhalten, sei
auf die Hilfe von \verb|nlminb| verwiesen.

Bei der IFM- und CML-Methode sind die Parameter sehr ähnlich, nur die
EML-Methode liefert einen unbrauchbaren Wert f\"ur $\theta$. Auch die
zweitbesten Anpassungen stimmen bei CML- und IFM-Methode \"uberein.

Wie erwartet, ist die Rechenzeit bei der EML-Methode am
längsten. Jedoch kann trotz der hohen Anzahl an Iterationen keine
Konvergenz erreicht werden.
